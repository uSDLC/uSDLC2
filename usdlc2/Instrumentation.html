<html>
<head>
	<title></title>
	<link href="document.css" rel="stylesheet" type="text/css" />
</head>
<body class="scayt-enabled">
<h1 style="">Instrumentation</h1>

<h2 style="">Given, When, Then <span style="font-size:14px;">(<a href="http://www.screencast.com/t/80uvUtK2v">screencast</a>)</span></h2>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee">server = gwt.server()

gwt.rules(
  /a number between (\d+) and (\d+)/, (start, end) -&gt;
    @number = +start + Math.floor(Math.random() *
                                  (+end - +start))
    @test(@number &lt; 10, @number)
    
  /multiply the number by (\d+)/, (multiplicand) -&gt;
    @number *= multiplicand
    @pass(@number)

  /the result is an even number/, -&gt;
    @test not (@number % 2), @number
)</textarea></p>

<p style="display: block;"><em><strong>uSDLC</strong></em> will process any set of natural language&nbsp;statements in a GWT block. New blocks can be created with the target icon on the uSDLC tab - given&nbsp;a type of <em>gwt</em>.</p>

<h3 style="">A Basic Example</h3>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<p style="display: block;">Instrumentation&nbsp;consists of a GWT block (below) and the instrumentation bridge code. You can view the code at any time from the bridge icon on the uSDLC tab or the reference link at the end of a section. Bridge code is broken up into&nbsp;a block for each&nbsp;heading leading&nbsp;to the current section. In this way&nbsp;common code is available between sections.</p>

<pre contenteditable="false" style="display: block;" type="gwt">
Given a number between 1 and 10
When we multiply the number by 2
Then the result is an even number
</pre>

<p style="display: block;">More than one GWT block can reside in each section. They are concatenated for the purposes of instrumentation.</p>

<pre style="width: 454.75px; display: block;" type="gwt">
Given a number between 1 and 10
When we multiply the number by 2
Then the result is an even number</pre>

<div class="metadata Ref" style="display: block;">Ref: <span class="Bridge"><a href="javascript:usdlc.bridge_editor()">Bridge</a></span><span class="Play"><a href="javascript:usdlc.play()">Play</a></span><span class="script_extractor"><a href="javascript:usdlc.edit_source({value:'script_extractor.coffee',path:'server/script_extractor.coffee',category:'server'})">script_extractor.coffee</a></span><span class="code"><a href="javascript:usdlc.edit_source({value:'code.coffee',path:'client/ckeditor/code.coffee',category:'ckeditor'})">code.coffee</a></span><span class="editor"><a href="javascript:usdlc.edit_source({value:'editor.coffee',path:'client/codemirror/editor.coffee',category:'codemirror'})">editor.coffee</a></span><span class="codemirror"><a href="javascript:usdlc.edit_source({value:'codemirror.coffee',path:'client/codemirror/codemirror.coffee',category:'codemirror'})">codemirror.coffee</a></span></div>

<h3 style="">Built-in Rules</h3>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<h4 style="">Given a Shell, Fork or Spawn</h4>

<h4 style="">Checking Output Content</h4>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<p> </p>

<h5 style="">Checking Output by Substring</h5>

<p> </p>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<p style="display: block;">Instrumentation captures output from actions and running sub-systems. Sometimes this is the best way to measure a response. For simplicity you can scan the output for a substring.</p>

<pre style="display: block;" type="gwt">
Given a number between 1 and 10
Then the response includes '<span data-scayt_word="ecking" data-scaytid="4">ecking</span> Output Co'</pre>

<div class="metadata Ref" style="display: block;">Ref: <span class="Bridge"><a href="javascript:usdlc.bridge_editor()">Bridge</a></span><span class="Play"><a href="javascript:usdlc.play()">Play</a></span><span class="java"><a href="javascript:usdlc.edit_source({value:'java.coffee',path:'server/gwt/java.coffee',category:'gwt'})">java.coffee</a></span><span class="index"><a href="javascript:usdlc.edit_source({value:'index.coffee',path:'server/gwt/index.coffee',category:'gwt'})">index.coffee</a></span><span class="server"><a href="javascript:usdlc.edit_source({value:'server.coffee',path:'server/gwt/server.coffee',category:'gwt'})">server.coffee</a></span><span class="processes"><a href="javascript:usdlc.edit_source({value:'processes.coffee',path:'server/gwt/processes.coffee',category:'gwt'})">processes.coffee</a></span></div>

<h5 style="">Checking Output by Regular Expression</h5>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<p style="display: block;">For more complicated checks&nbsp;nothing beats regular expressions. They are, however, less readable.</p>

<pre style="display: block;" type="gwt">
Given a number between 1 and 10
Then response matches /.*ok 1 - \d/</pre>

<div class="metadata Ref" style="display: block;">Ref: <span class="metadata"><a href="javascript:usdlc.edit_source({value:'metadata.coffee',path:'client/ckeditor/metadata.coffee',category:'ckeditor'})">metadata.coffee</a></span><span class="bridge"><a href="javascript:usdlc.edit_source({value:'bridge.coffee',path:'client/ckeditor/bridge.coffee',category:'ckeditor'})">bridge.coffee</a></span></div>

<h3 style="">Child Process Output</h3>

<pre style="display: block;" type="gwt">
Given a shell
When we execute 'echo uSDLC child output test'
Then the response includes 'uSDLC child output test'</pre>

<div class="metadata Ref" style="display: block;">Ref: <span class="app"><a href="javascript:usdlc.edit_source({value:'app.coffee',path:'app.coffee',category:'.'})">app.coffee</a></span><span class="sections"><a href="javascript:usdlc.edit_source({value:'sections.coffee',path:'client/ckeditor/sections.coffee',category:'ckeditor'})">sections.coffee</a></span></div>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<h2>Code and Data</h2>

<p style="display: block;">Given/When/Then is a specific example of a code segment. For developers by developers, instrumentation will be by code examples rather than 'natural language'.</p>

<h3 style="display: block;">CoffeeScript/JavaScript</h3>

<p style="display: block;">Each code segment acts as an independent Node module. The only visible entity returned is <em>module.exports</em> - and it should be a function.</p>

<h4>Instrumentation Steps</h4>

<p style="display: block;">If the module is a function without parameters then it will be queued as an instrumentation steps. These steps are only run after all the segments have been loaded. They run in the <em>gwt</em> context and complete with an <em>@pass()</em> or <em>@fail()</em>.</p>

<pre style="display: block;" title="coffee" type="coffee">
module.exports = -&gt;
  @pass "adding instrument steps directly"
</pre>

<div class="metadata Ref" style="display: block;">Ref: <span class="Bridge"><a href="javascript:usdlc.bridge_editor()">Bridge</a></span><span class="Play"><a href="javascript:usdlc.play()">Play</a></span><span class="bridge"><a href="javascript:usdlc.edit_source({value:'bridge.coffee',path:'client/ckeditor/bridge.coffee',category:'ckeditor'})">bridge.coffee</a></span><span class="code"><a href="javascript:usdlc.edit_source({value:'code.coffee',path:'client/ckeditor/code.coffee',category:'ckeditor'})">code.coffee</a></span><span class="play"><a href="javascript:usdlc.edit_source({value:'play.coffee',path:'client/ckeditor/play.coffee',category:'ckeditor'})">play.coffee</a></span></div>

<h4>Asynchronous Action</h4>

<p style="display: block;">If the module is a function with one parameter - it is expected to be a callback. Unlike instrumentation steps these modules are called immediately during the build phase - with further processing held until the callback. Use these actions to load data or code before the instrumentation phase starts. They run in gwt context - so this can be used to share data.</p>

<pre style="display: block;" title="coffee" type="coffee">
module.exports = (ready) -&gt;
  fetch_data = =&gt;
    @my_data = "hello world"
    ready()
  <span data-scayt_word="setTimeout" data-scaytid="6">setTimeout</span> fetch_data, 10</pre>

<p style="display: block;">Now we create an instrumentation step that confirms the preparations. Note that we had to add explicitly, as uSDLC combines all scripts of the same type in a section.</p>

<pre style="display: block;" title="coffee" type="gwt.coffee">
require('gwt').add -&gt;
  @test @my_data, "hello world"</pre>

<div class="metadata Ref" style="display: block;">Ref: <span class="Bridge"><a href="javascript:usdlc.bridge_editor()">Bridge</a></span><span class="Play"><a href="javascript:usdlc.play()">Play</a></span><span class="code"><a href="javascript:usdlc.edit_source({value:'code.coffee',path:'client/ckeditor/code.coffee',category:'ckeditor'})">code.coffee</a></span><span class="app"><a href="javascript:usdlc.edit_source({value:'app.coffee',path:'app.coffee',category:'.'})">app.coffee</a></span><span class="base"><a href="javascript:usdlc.edit_source({value:'base.coffee',path:'server/gwt/base.coffee',category:'gwt'})">base.coffee</a></span><span class="index"><a href="javascript:usdlc.edit_source({value:'index.coffee',path:'server/gwt/index.coffee',category:'gwt'})">index.coffee</a></span></div>

<h3>Other Languages</h3>

<p>Anything is possible. If you are instrumenting with code, then your audience involves developers, so the code will either be libraries for them to use or low level components of the production system.</p>

<p style="display: block;">Where possible it is good to test code in isolation before integration. Other approaches include server integration, code injections and FICL.</p>

<h4>Library Instrumentation <span style="font-size:14px;">(<a href="http://www.screencast.com/t/SprHndAo">screencast</a>)</span></h4>

<p><strong>Example</strong>:&nbsp;<a href="https://github.com/uSDLC/FICL"><em><strong>FICL</strong></em></a>&nbsp;(Fast Integrated Command Language)&nbsp;<em><strong>API</strong></em>&nbsp;- A library used to automate procedures in systems using compiled languages. Clone it and add it to uSDLC2. The document API is referenced below.</p>

<p style="display: block;">For modules with few or well-defined dependencies it is possible to wrap a small command-line program around them.</p>

<div class="metadata Ref">Ref: <span class="code"><a href="javascript:usdlc.edit_source({value:'code.coffee',path:'client/ckeditor/code.coffee',category:'ckeditor'})">code.coffee</a></span><span class="codemirror"><a href="javascript:usdlc.edit_source({value:'codemirror.coffee',path:'client/codemirror/codemirror.coffee',category:'codemirror'})">codemirror.coffee</a></span><span class="bridge"><a href="javascript:usdlc.edit_source({value:'bridge.coffee',path:'client/ckeditor/bridge.coffee',category:'ckeditor'})">bridge.coffee</a></span><span class="edit_source"><a href="javascript:usdlc.edit_source({value:'edit_source.coffee',path:'client/edit_source.coffee',category:'client'})">edit_source.coffee</a></span><span class="editor"><a href="javascript:usdlc.edit_source({value:'editor.coffee',path:'client/codemirror/editor.coffee',category:'codemirror'})">editor.coffee</a></span><span class="terminal"><a href="javascript:usdlc.edit_source({value:'terminal.coffee',path:'client/ckeditor/terminal.coffee',category:'ckeditor'})">terminal.coffee</a></span><span class="source_editor"><a href="javascript:usdlc.edit_source({value:'source_editor.coffee',path:'client/ckeditor/source_editor.coffee',category:'ckeditor'})">source_editor.coffee</a></span><span class="tree_filer"><a href="javascript:usdlc.edit_source({value:'tree_filer.coffee',path:'client/tree_filer.coffee',category:'client'})">tree_filer.coffee</a></span><span class="create_project"><a href="javascript:usdlc.edit_source({value:'create_project.coffee',path:'client/ckeditor/create_project.coffee',category:'ckeditor'})">create_project.coffee</a></span></div>

<h5 style="display: block;">Scaffold</h5>

<p>Many languages require a lot of support code for each instrumentation section. I place scaffolding code at the end of the page in a section with the same name. Scaffolding will instantiate the command and provide supporting code.</p>

<p>In the Java example it is an abstract parent class so that test code need only override <em>instrument()</em>. The support functions below print error messages on unexpected results and the program prints out an <em>Errors:</em> line when it is done so that <em><strong>uSDLC2</strong></em> knows to complete the section.</p>

<div class="metadata Ref">Ref: <span class="sections"><a href="javascript:usdlc.edit_source({value:'sections.coffee',path:'client/ckeditor/sections.coffee',category:'ckeditor'})">sections.coffee</a></span><span class="code"><a href="javascript:usdlc.edit_source({value:'code.coffee',path:'client/ckeditor/code.coffee',category:'ckeditor'})">code.coffee</a></span><span class="bridge"><a href="javascript:usdlc.edit_source({value:'bridge.coffee',path:'client/ckeditor/bridge.coffee',category:'ckeditor'})">bridge.coffee</a></span><span class="source_editor"><a href="javascript:usdlc.edit_source({value:'source_editor.coffee',path:'client/ckeditor/source_editor.coffee',category:'ckeditor'})">source_editor.coffee</a></span><span class="edit_source"><a href="javascript:usdlc.edit_source({value:'edit_source.coffee',path:'client/edit_source.coffee',category:'client'})">edit_source.coffee</a></span></div>

<h5 style="display: block;">Instrumentation</h5>

<p>The intended audiences are developers - so the behavioural&nbsp;examples are in a target language for the library (code).</p>

<p>Look at section 4.2 in FICL/API for a good example.</p>

<p>Java requires that the class name reflects the file-name, so use the section name replacing non-word characters with underscore. This restriction does not occur in most other languages.</p>

<p>Note that we extend Scaffold and create a main method so the library can be run from the command line.</p>

<p>The heavy lifting is done in the <em><strong>instrument</strong></em> method. I have wrapped it in comments to make it stand out. In this example we are checking that shared storage can trigger a <em><strong>FICL</strong></em> word when data changes.</p>

<div class="metadata Ref">Ref: <span class="java"><a href="javascript:usdlc.edit_source({value:'java.coffee',path:'server/gwt/java.coffee',category:'gwt'})">java.coffee</a></span><span class="server"><a href="javascript:usdlc.edit_source({value:'server.coffee',path:'server/gwt/server.coffee',category:'gwt'})">server.coffee</a></span><span class="rules"><a href="javascript:usdlc.edit_source({value:'rules.coffee',path:'server/gwt/rules.coffee',category:'gwt'})">rules.coffee</a></span></div>

<h5 style="display: block;">Bridge</h5>

<p style="display: block;">The bridge will build the command-line program from fixed components like scaffolding and libraries, plus files from the current section. All files in a section are concatenated before compiled or executed. The bridge can also provide code to be run for each file in the section by extension - so it can be used to compile or run the command-line tool.</p>

<p style="display: block;">The <em><strong>gwt</strong></em> object can be extended with tools for different systems. Here we use the most primitive Java one as it does not rely on a build tool like ant, maven or make. We compile the support code. The we add console output monitors looking for pass or fail conditions. Lastly we add a new file process that knows about Java files as instrumentation blocks. Each time a Java file is found in a section it is compiled and run as a command-line application.</p>

<h5 style="display: block;">Play</h5>

<p><em><strong>uSDLC2</strong></em> records a pass or fail on a section based on the number of errors reported.</p>

<h5 style="display: block;">Libraries with Side-Effects</h5>

<p style="display: block;">For libraries with side-effects (such as connections to a database), then it may be better to use a REPL instrumentation approach.</p>

<div class="metadata Ref">Ref: <span class="java"><a href="javascript:usdlc.edit_source({value:'java.coffee',path:'server/gwt/java.coffee',category:'gwt'})">java.coffee</a></span><span class="index"><a href="javascript:usdlc.edit_source({value:'index.coffee',path:'server/gwt/index.coffee',category:'gwt'})">index.coffee</a></span><span class="script_extractor"><a href="javascript:usdlc.edit_source({value:'script_extractor.coffee',path:'server/script_extractor.coffee',category:'server'})">script_extractor.coffee</a></span></div>

<h4>REPL Instrumentation <span style="font-size:14px;">(<a href="http://www.screencast.com/t/7KkYTEKnLs">screencast</a>)</span></h4>

<p style="display: block;">Components can be instrumented in isolation using a REPL (read, execute, print, loop). Many systems, including Groovy, Python and Node-JS come standard with a REPL.</p>

<p><strong>Example</strong>:&nbsp;<a href="https://github.com/uSDLC/FICL"><em><strong>FICL</strong></em></a>&nbsp;(Fast Integrated Command Language)&nbsp;<em><strong>Reference</strong></em>&nbsp;- A library used to automate procedures in systems using compiled languages. Clone it and add it to uSDLC2.</p>

<p><em><strong>FICL</strong></em> comes with a simple REPL specifically designed for USDLC2 testing. For other languages you will need to load a script to provide similar functionality.</p>

<p>The second section is the REPL itself - reading lines from the 'console' and executing them.</p>

<p>The bridge is similar across languages instrumented though a REPL.</p>

<ol>
	<li>Make sure instrumented code is up to date</li>
	<li>Recognise pass and fail conditions in console output</li>
	<li>Load instrumentation scripts by file extension</li>
</ol>

<p>Playing sections starts the REPL and feeds it commands from the requested sections. Click ... to see the rest of the output.</p>

<h4>Server Integrated Instrumentation</h4>

<p>The following code would normally be part of the bridge. The gwt object has a method for loading server support.</p>

<pre title="coffee" type="coffee">
server = gwt.server()</pre>

<p class="metadata Ref">We can now add one or more servers.</p>

<pre title="coffee" type="coffee">
<span data-scayt_word="stop_url" data-scaytid="30">stop_url</span> = 'server/http/terminate.coffee?signal=<span data-scayt_word="SIGKILL" data-scaytid="33">SIGKILL</span>'

server.add
  'roaster':
    <span data-scayt_word="url" data-scaytid="34">url</span>: 'http://<span data-scayt_word="localhost" data-scaytid="35">localhost</span>:9019'
    <span data-scayt_word="dir" data-scaytid="36">dir</span>: '../roaster'
    start_command: "./go.sh server port=9019"
    <span data-scayt_word="stop_url" data-scaytid="31">stop_url</span>: <span data-scayt_word="stop_url" data-scaytid="32">stop_url</span></pre>

<p class="metadata Ref">You can use <em>stop_command</em> or <em>stop_url</em>. Some servers have start and stop scripts, while others can easily be terminated except by internal process.</p>

<p class="metadata Ref">The server also adds rules to start a server. Note that in the example we attempt to start the server twice. The start command always checks to see if it is running before trying again.</p>

<pre title="gwt" type="gwt">
Given a running roaster server
and we start a roaster server</pre>

<p class="metadata Ref"> </p>

<div class="metadata Ref">Ref: <span class="Bridge"><a href="javascript:usdlc.bridge_editor()">Bridge</a></span><span class="Play"><a href="javascript:usdlc.play()">Play</a></span><span class="server"><a href="javascript:usdlc.edit_source({value:'server.coffee',path:'server/gwt/server.coffee',category:'gwt'})">server.coffee</a></span></div>

<h4>Code Injection</h4>

<p style="display: block;">Code injection can be used for all interactive languages such as Groovy, Ruby, Python or JavaScript. They require a transport mechanism to make the files available and code on the target system to ingest and run the injected code.</p>

<p style="display: block;">The transport depends on the target system. For servers, a HTTP request is easiest. For browsers they can make a web-socket connection to uSDLC. For many systems it is just a matter of copying the files in a known location.</p>

<p style="display: block;">Running injected code involves a security risk. This is easily mitigated with basic precautions - such that uSDLC must be running on the same computer as the target system.</p>

<h5>Browser / JavaScript</h5>

<h5>​Server / Roaster / Node-JS / Coffeescript</h5>

<h5>FICL</h5>

<p style="display: block;">Some systems are static and can't be easily rebuilt on-the-fly for instrumentation. This includes many large Java and .NET system as well as most mobile devices. For these environments we provide FICL (fast integrated configuration language) - a very lightweight system for injecting instrumentation. There are Java versions for Android and C versions for .NET and iOS.</p>

<div style="background-color: rgb(238, 238, 238); border: 1px solid rgb(204, 204, 204); padding: 5px 10px; display: block; background-position: initial initial; background-repeat: initial initial;"><span style="color:#FF0000;">Create an example from FICL/REFERENCE</span></div>

<h2>The Bridge</h2>

<p style="display: block;">The bridge is code that connects rules to the operational system and other external resources. It is recorded within the document and extracted to be run. Any&nbsp;GWT block can access bridge code from it's section and all connected parent sections.</p>

<p>Every section can have associated bridge code. When played, the bridge for this section and all parents are available.</p>

<p>Bridge code is written in CoffeeScript, although any JavaScript variant can be made available.</p>

<p>Call&nbsp;<em>gwt.rules</em>&nbsp;with paired parameters being a regular expression and code to execute. Complete a step and move on with</p>

<ul>
	<li>@pass(message)</li>
	<li>@fail(message)</li>
	<li>@test(boolean, message) - pass or fail based on a boolean value</li>
	<li>@check(value, to_be) - compare two values, same is a pass</li>
	<li>@check_for_error(error, message) - fail on error, otherwise pass</li>
	<li>@todo(message) - fail with a TODO marker</li>
	<li>@skip(message) - pass with a SKIP marker</li>
	<li>@includes_text(text) - pass if system output includes the text</li>
	<li>@matches_text(regex) - pass if regex finds a match in output</li>
	<li>@expect(pass, fail, end) - monitor output for conditional regex</li>
</ul>

<p>Setting&nbsp;<em>@expect_failure</em>&nbsp;will reverse the test results.</p>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<div class="metadata Ref" style="display: block;">Ref:&nbsp;<span class="bridge"><a href="javascript:usdlc.edit_source({value:'bridge.coffee',path:'client/ckeditor/bridge.coffee',category:'ckeditor'})">bridge.coffee</a></span><span class="play"><a href="javascript:usdlc.edit_source({value:'play.coffee',path:'client/ckeditor/play.coffee',category:'ckeditor'})">play.coffee</a></span></div>

<h3>Rule Cascade</h3>

<p>If rules are to be common across sections, move them up to a parent that is available to both. If rules share common functionality, move that to a function and elevate it to a parent bridge.</p>

<h3>The&nbsp;<em>gwt</em>&nbsp;Object</h3>

<h3>Rules</h3>

<h4>Regular Expressions</h4>

<p>The first regular expression that matches a statement is used. It can use braces to mark parameters to pass to the action.</p>

<h4>Actions</h4>

<p>Each action counts as a test and must pass or fail before the instrumentation will continue. Most actions interact with production code through a REPL, an API, the browser or FICL.</p>

<h3>Asynchronous Support</h3>

<p style="display: block;">A rule is complete when it is marked pass or fail.&nbsp;Each rule has a queue for&nbsp;&nbsp;asynchronous operations. Each queue entry&nbsp;will complete and allow the next to start when @pass() is called. If there are no more steps, @pass() will complete the rule as usual. If @fail is called all further steps are skipped and the rule fails.</p>

<pre style="display: block;" type="gwt">
A rule with steps
A rule that would fail mid-step if we permitted it
</pre>

<div class="metadata Ref" style="display: block;">Ref: <span class="Bridge"><a href="javascript:usdlc.bridge_editor()">Bridge</a></span><span class="Play"><a href="javascript:usdlc.play()">Play</a></span><span class="base"><a href="javascript:usdlc.edit_source({value:'base.coffee',path:'server/gwt/base.coffee',category:'gwt'})">base.coffee</a></span><span class="index"><a href="javascript:usdlc.edit_source({value:'index.coffee',path:'server/gwt/index.coffee',category:'gwt'})">index.coffee</a></span><span class="files"><a href="javascript:usdlc.edit_source({value:'files.coffee',path:'server/http/files.coffee',category:'http'})">files.coffee</a></span></div>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee">count = 0

# async function that waits 1/10th of a sec then checks value
# should fail if another piece of code races ahead
heartbeat = (expects) -&gt; gwt.queue -&gt;
  tick = -&gt;
    gwt.expect(count++, expects)
  setTimeout(tick, 100)

gwt.rules(
  /A rule with steps/, -&gt;
    heartbeat 0
    heartbeat 1
    heartbeat 2
  
  /A rule that would fail mid-step/, -&gt;
    @expect_failure = true
    
    @queue -&gt;
      count = 0
      @pass()
      
    heartbeat 0
    heartbeat 5
    heartbeat 2
)</textarea></p>

<h2>Play Instrumentation</h2>

<p>Playing the instrumentation brings up a screen and displays output as it comes. Groups that include failures are shaded red.</p>

<h3>Console Output</h3>

<p>Details and console output are captured. Only the first line is displayed. Click on ... to see the rest.</p>

<h3>TAP</h3>

<p>This screen is a fancy formatting for the TAP (test anything protocol).</p>

<h3>Command Line Execution</h3>

<p>Copy the command at the top of the screen and run it in a terminal. It can also be used for testing during development and continuous integration.</p>
</body>
</html>
