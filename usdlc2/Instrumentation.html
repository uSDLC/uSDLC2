<html>
<head>
	<title></title>
	<link href="document.css" rel="stylesheet" type="text/css" />
</head>
<body class="scayt-enabled">
<h1 style="">Instrumentation</h1>

<h2 style="">Given, When, Then <span style="font-size:14px;">(<a href="http://www.screencast.com/t/80uvUtK2v">screencast</a>)</span></h2>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee">server = gwt.server()

gwt.rules(
  /a number between (\d+) and (\d+)/, (start, end) -&gt;
    @number = +start + Math.floor(Math.random() *
                                  (+end - +start))
    @test(@number &lt; 10, @number)
    
  /multiply the number by (\d+)/, (multiplicand) -&gt;
    @number *= multiplicand
    @pass(@number)

  /the result is an even number/, -&gt;
    @test not (@number % 2), @number
)</textarea></p>

<p style="display: block;"><em><strong>uSDLC</strong></em> will process any set of natural language&nbsp;statements in a GWT block. New blocks can be created with the target icon on the uSDLC tab - given&nbsp;a type of <em>gwt</em>.</p>

<div class="metadata Ref">Ref: <span class="instrument"><a href="javascript:usdlc.edit_source({value:'instrument.coffee',path:'instrument.coffee',category:'.'})">instrument.coffee</a></span><span class="gwt"><a href="javascript:usdlc.edit_source({value:'gwt.coffee',path:'scripts/gwt.coffee',category:'scripts'})">gwt.coffee</a></span></div>

<h3 style="">A Basic Example</h3>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<p style="display: block;">Instrumentation&nbsp;consists of a GWT block (below) and the instrumentation bridge code. You can view the code at any time from the bridge icon on the uSDLC tab or the reference link at the end of a section. Bridge code is broken up into a block for each&nbsp;heading leading&nbsp;to the current section. In this way&nbsp;common code is available between sections.</p>

<pre contenteditable="false" style="display: block;" type="gwt">
Given a number between 1 and 10
When we multiply the number by 2
Then the result is an even number
</pre>

<p style="display: block;">More than one GWT block can reside in each section. They are concatenated for the purposes of instrumentation.</p>

<pre style="width: 454.75px; display: block;" type="gwt">
Given a number between 1 and 10
When we multiply the number by 2
Then the result is an even number</pre>

<div class="metadata Ref" style="display: block;">Ref: <span class="Bridge"><a href="javascript:usdlc.bridge_editor()">Bridge</a></span><span class="Play"><a href="javascript:usdlc.play()">Play</a></span><span class="script_extractor"><a href="javascript:usdlc.edit_source({value:'script_extractor.coffee',path:'server/script_extractor.coffee',category:'server'})">script_extractor.coffee</a></span><span class="code"><a href="javascript:usdlc.edit_source({value:'code.coffee',path:'client/ckeditor/code.coffee',category:'ckeditor'})">code.coffee</a></span><span class="editor"><a href="javascript:usdlc.edit_source({value:'editor.coffee',path:'client/codemirror/editor.coffee',category:'codemirror'})">editor.coffee</a></span><span class="compiler"><a href="javascript:usdlc.edit_source({value:'compiler.coffee',path:'server/gwt/compiler.coffee',category:'gwt'})">compiler.coffee</a></span><span class="io"><a href="javascript:usdlc.edit_source({value:'io.coffee',path:'server/gwt/io.coffee',category:'gwt'})">io.coffee</a></span><span class="index"><a href="javascript:usdlc.edit_source({value:'index.coffee',path:'server/gwt/index.coffee',category:'gwt'})">index.coffee</a></span><span class="file_processor"><a href="javascript:usdlc.edit_source({value:'file_processor.coffee',path:'server/gwt/file_processor.coffee',category:'gwt'})">file_processor.coffee</a></span><span class="files"><a href="javascript:usdlc.edit_source({value:'files.coffee',path:'server/gwt/files.coffee',category:'gwt'})">files.coffee</a></span><span class="processes"><a href="javascript:usdlc.edit_source({value:'processes.coffee',path:'server/gwt/processes.coffee',category:'gwt'})">processes.coffee</a></span><span class="codemirror"><a href="javascript:usdlc.edit_source({value:'codemirror.coffee',path:'client/codemirror/codemirror.coffee',category:'codemirror'})">codemirror.coffee</a></span><span class="source_editor"><a href="javascript:usdlc.edit_source({value:'source_editor.coffee',path:'client/ckeditor/source_editor.coffee',category:'ckeditor'})">source_editor.coffee</a></span><span class="create_project"><a href="javascript:usdlc.edit_source({value:'create_project.coffee',path:'client/ckeditor/create_project.coffee',category:'ckeditor'})">create_project.coffee</a></span><span class="dir_tree"><a href="javascript:usdlc.edit_source({value:'dir_tree.coffee',path:'client/dir_tree.coffee',category:'client'})">dir_tree.coffee</a></span></div>

<h3 style="">Statement Reuse</h3>

<p>In a typical document later paragraphs build on information given earlier. uSDLC2 supports this with the statement</p>

<div style="background:#eee;border:1px solid #ccc;padding:5px 10px;">... 'Section Heading RE' from above</div>

<p>The bridge code must reside in a section that is parent to both the current and referenced sections. This example will run the same test three times.</p>

<pre title="gwt" type="gwt">
Given 'A Basic Example' from above
When we multiply the number by 2
Then the result is an even number</pre>

<p> </p>

<div class="metadata Ref">Ref: <span class="tree_filer"><a href="javascript:usdlc.edit_source({value:'tree_filer.coffee',path:'client/tree_filer.coffee',category:'client'})">tree_filer.coffee</a></span><span class="tree"><a href="javascript:usdlc.edit_source({value:'tree.coffee',path:'client/tree.coffee',category:'client'})">tree.coffee</a></span><span class="dir_tree"><a href="javascript:usdlc.edit_source({value:'dir_tree.coffee',path:'client/dir_tree.coffee',category:'client'})">dir_tree.coffee</a></span></div>

<h3 style="">Built-in Rules</h3>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<div class="metadata Ref">Ref: <span class="source_editor"><a href="javascript:usdlc.edit_source({value:'source_editor.coffee',path:'client/ckeditor/source_editor.coffee',category:'ckeditor'})">source_editor.coffee</a></span><span class="dir_tree"><a href="javascript:usdlc.edit_source({value:'dir_tree.coffee',path:'client/dir_tree.coffee',category:'client'})">dir_tree.coffee</a></span></div>

<h4 style="">Given a Shell, Fork or Spawn</h4>

<h4 style="">Checking Output Content</h4>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<h5 style="">Checking Output by Substring</h5>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<p style="display: block;">Instrumentation captures output from actions and running sub-systems. Sometimes this is the best way to measure a response. For simplicity you can scan the output for a substring.</p>

<pre style="display: block;" type="gwt">
Given a number between 1 and 10
Then the response includes '<span data-scayt_word="ecking" data-scaytid="2">ecking</span> Output Co'</pre>

<div class="metadata Ref" style="display: block;">Ref: <span class="Bridge"><a href="javascript:usdlc.bridge_editor()">Bridge</a></span><span class="Play"><a href="javascript:usdlc.play()">Play</a></span><span class="java"><a href="javascript:usdlc.edit_source({value:'java.coffee',path:'server/gwt/java.coffee',category:'gwt'})">java.coffee</a></span><span class="index"><a href="javascript:usdlc.edit_source({value:'index.coffee',path:'server/gwt/index.coffee',category:'gwt'})">index.coffee</a></span><span class="server"><a href="javascript:usdlc.edit_source({value:'server.coffee',path:'server/gwt/server.coffee',category:'gwt'})">server.coffee</a></span><span class="processes"><a href="javascript:usdlc.edit_source({value:'processes.coffee',path:'server/gwt/processes.coffee',category:'gwt'})">processes.coffee</a></span></div>

<h5 style="">Checking Output by Regular Expression</h5>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<p style="display: block;">For more complicated checks&nbsp;nothing beats regular expressions. They are, however, less readable.</p>

<pre style="display: block;" type="gwt">
Given a number between 1 and 10
Then response matches /.*ok 1 - \d/</pre>

<div class="metadata Ref" style="display: block;">Ref: <span class="metadata"><a href="javascript:usdlc.edit_source({value:'metadata.coffee',path:'client/ckeditor/metadata.coffee',category:'ckeditor'})">metadata.coffee</a></span><span class="bridge"><a href="javascript:usdlc.edit_source({value:'bridge.coffee',path:'client/ckeditor/bridge.coffee',category:'ckeditor'})">bridge.coffee</a></span></div>

<h3 style="">Child Process Output</h3>

<pre style="display: block;" type="gwt">
Given a shell
When we execute 'echo uSDLC child output test'
Then the response includes 'uSDLC child output test'</pre>

<div class="metadata Ref" style="display: block;">Ref: <span class="app"><a href="javascript:usdlc.edit_source({value:'app.coffee',path:'app.coffee',category:'.'})">app.coffee</a></span><span class="sections"><a href="javascript:usdlc.edit_source({value:'sections.coffee',path:'client/ckeditor/sections.coffee',category:'ckeditor'})">sections.coffee</a></span></div>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<h2>Code and Data</h2>

<p style="display: block;">Given/When/Then is a specific example of a code segment. For developers by developers, instrumentation will be by code examples rather than 'natural language'.</p>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<h3 style="display: block;">CoffeeScript/JavaScript</h3>

<p style="display: block;">Each code segment acts as an independent Node module. The only visible entity returned is <em>module.exports</em> - and it should be a function.</p>

<h4>Instrumentation Steps</h4>

<p style="display: block;">If the module is a function without parameters then it will be queued as an instrumentation steps. These steps are only run after all the segments have been loaded. They run in the <em>gwt</em> context and complete with an <em>@pass()</em> or <em>@fail()</em>.</p>

<pre style="display: block;" title="coffee" type="coffee">
module.exports = -&gt;
  @pass "adding instrument steps directly"
</pre>

<div class="metadata Ref" style="display: block;">Ref: <span class="Bridge"><a href="javascript:usdlc.bridge_editor()">Bridge</a></span><span class="Play"><a href="javascript:usdlc.play()">Play</a></span><span class="bridge"><a href="javascript:usdlc.edit_source({value:'bridge.coffee',path:'client/ckeditor/bridge.coffee',category:'ckeditor'})">bridge.coffee</a></span><span class="code"><a href="javascript:usdlc.edit_source({value:'code.coffee',path:'client/ckeditor/code.coffee',category:'ckeditor'})">code.coffee</a></span><span class="play"><a href="javascript:usdlc.edit_source({value:'play.coffee',path:'client/ckeditor/play.coffee',category:'ckeditor'})">play.coffee</a></span></div>

<h4>Asynchronous Action</h4>

<p style="display: block;">If the module is a function with one parameter - it is expected to be a callback. Unlike instrumentation steps these modules are called immediately during the build phase - with further processing held until the callback. Use these actions to load data or code before the instrumentation phase starts. They run in gwt context - so this can be used to share data.</p>

<pre style="display: block;" title="coffee" type="coffee">
module.exports = (ready) -&gt;
  fetch_data = =&gt;
    @my_data = "hello world"
    ready()
  setTimeout fetch_data, 10</pre>

<p style="display: block;">Now we create an instrumentation step that confirms the preparations. Note that we had to add explicitly, as uSDLC combines all scripts of the same type in a section.</p>

<pre style="display: block;" title="coffee" type="gwt.coffee">
require('gwt').add -&gt;
  @test @my_data, "hello world"</pre>

<div class="metadata Ref" style="display: block;">Ref: <span class="Bridge"><a href="javascript:usdlc.bridge_editor()">Bridge</a></span><span class="Play"><a href="javascript:usdlc.play()">Play</a></span><span class="code"><a href="javascript:usdlc.edit_source({value:'code.coffee',path:'client/ckeditor/code.coffee',category:'ckeditor'})">code.coffee</a></span><span class="app"><a href="javascript:usdlc.edit_source({value:'app.coffee',path:'app.coffee',category:'.'})">app.coffee</a></span><span class="base"><a href="javascript:usdlc.edit_source({value:'base.coffee',path:'server/gwt/base.coffee',category:'gwt'})">base.coffee</a></span><span class="index"><a href="javascript:usdlc.edit_source({value:'index.coffee',path:'server/gwt/index.coffee',category:'gwt'})">index.coffee</a></span></div>

<h3>Other Languages</h3>

<p style="display: block;">Anything is possible. If you are instrumenting with code, then your audience involves developers, so the code will either be libraries for them to use or low level components of the production system.</p>

<p style="display: block;">Where possible it is good to test code in isolation before integration. Other approaches include server integration, code injections and FICL.</p>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<h4>Library Instrumentation <span style="font-size:14px;">(<a href="http://www.screencast.com/t/SprHndAo">screencast</a>)</span></h4>

<p style="display: block;"><strong>Example</strong>:&nbsp;<a href="https://github.com/uSDLC/FICL"><em><strong>FICL</strong></em></a>&nbsp;(Fast Integrated Command Language)&nbsp;<em><strong>API</strong></em>&nbsp;- A library used to automate procedures in systems using compiled languages. Clone it and add it to uSDLC2. The document API is referenced below.</p>

<p style="display: block;">For modules with few or well-defined dependencies it is possible to wrap a small command-line program around them.</p>

<h5 style="display: block;">Scaffold</h5>

<p style="display: block;">Many languages require a lot of support code for each instrumentation section. I place scaffolding code at the end of the page in a section with the same name. Scaffolding will instantiate the command and provide supporting code.</p>

<p style="display: block;">In the Java example it is an abstract parent class so that test code need only override <em>instrument()</em>. The support functions below print error messages on unexpected results and the program prints out an <em>Errors:</em> line when it is done so that <em><strong>uSDLC2</strong></em> knows to complete the section.</p>

<div class="metadata Ref" style="display: block;">Ref: <span class="sections"><a href="javascript:usdlc.edit_source({value:'sections.coffee',path:'client/ckeditor/sections.coffee',category:'ckeditor'})">sections.coffee</a></span><span class="code"><a href="javascript:usdlc.edit_source({value:'code.coffee',path:'client/ckeditor/code.coffee',category:'ckeditor'})">code.coffee</a></span><span class="bridge"><a href="javascript:usdlc.edit_source({value:'bridge.coffee',path:'client/ckeditor/bridge.coffee',category:'ckeditor'})">bridge.coffee</a></span><span class="source_editor"><a href="javascript:usdlc.edit_source({value:'source_editor.coffee',path:'client/ckeditor/source_editor.coffee',category:'ckeditor'})">source_editor.coffee</a></span><span class="edit_source"><a href="javascript:usdlc.edit_source({value:'edit_source.coffee',path:'client/edit_source.coffee',category:'client'})">edit_source.coffee</a></span></div>

<h5 style="display: block;">Instrumentation</h5>

<p style="display: block;">The intended audiences are developers - so the behavioral&nbsp;examples are in a target language for the library (code).</p>

<p style="display: block;">Look at section 4.2 in FICL/API for a good example.</p>

<p style="display: block;">Java requires that the class name reflects the file-name, so use the section name replacing non-word characters with underscore. This restriction does not occur in most other languages.</p>

<p style="display: block;">Note that we extend Scaffold and create a main method so the library can be run from the command line.</p>

<p style="display: block;">The heavy lifting is done in the <em><strong>instrument</strong></em> method. I have wrapped it in comments to make it stand out. In this example we are checking that shared storage can trigger a <em><strong>FICL</strong></em> word when data changes.</p>

<div class="metadata Ref" style="display: block;">Ref: <span class="java"><a href="javascript:usdlc.edit_source({value:'java.coffee',path:'server/gwt/java.coffee',category:'gwt'})">java.coffee</a></span><span class="index"><a href="javascript:usdlc.edit_source({value:'index.coffee',path:'server/gwt/index.coffee',category:'gwt'})">index.coffee</a></span></div>

<h5 style="display: block;">Bridge</h5>

<p style="display: block;">The bridge will build the command-line program from fixed components like scaffolding and libraries, plus files from the current section. All files in a section are concatenated before compiled or executed. The bridge can also provide code to be run for each file in the section by extension - so it can be used to compile or run the command-line tool.</p>

<p style="display: block;">The <em><strong>gwt</strong></em> object can be extended with tools for different systems. Here we use the most primitive Java one as it does not rely on a build tool like ant, maven or make. We compile the support code. The we add console output monitors looking for pass or fail conditions. Lastly we add a new file process that knows about Java files as instrumentation blocks. Each time a Java file is found in a section it is compiled and run as a command-line application.</p>

<div class="metadata Ref">Ref: <span class="browser"><a href="javascript:usdlc.edit_source({value:'browser.coffee',path:'server/gwt/browser.coffee',category:'gwt'})">browser.coffee</a></span><span class="install-usdlc2"><a href="javascript:usdlc.edit_source({value:'install-usdlc2.sh',path:'install-usdlc2.sh',category:'.'})">install-usdlc2.sh</a></span><span class="script_extractor"><a href="javascript:usdlc.edit_source({value:'script_extractor.coffee',path:'server/script_extractor.coffee',category:'server'})">script_extractor.coffee</a></span></div>

<h5 style="display: block;">Play</h5>

<p style="display: block;"><em><strong>uSDLC2</strong></em> records a pass or fail on a section based on the number of errors reported.</p>

<div class="metadata Ref">Ref: <span class="install-usdlc2"><a href="javascript:usdlc.edit_source({value:'install-usdlc2.sh',path:'install-usdlc2.sh',category:'.'})">install-usdlc2.sh</a></span><span class="update"><a href="javascript:usdlc.edit_source({value:'update.sh',path:'update.sh',category:'.'})">update.sh</a></span><span class="compiler"><a href="javascript:usdlc.edit_source({value:'compiler.coffee',path:'server/gwt/compiler.coffee',category:'gwt'})">compiler.coffee</a></span><span class="java"><a href="javascript:usdlc.edit_source({value:'java.coffee',path:'server/gwt/java.coffee',category:'gwt'})">java.coffee</a></span></div>

<h5 style="display: block;">Libraries with Side-Effects</h5>

<p style="display: block;">For libraries with side-effects (such as connections to a database), then it may be better to use a REPL instrumentation approach.</p>

<div class="metadata Ref" style="display: block;">Ref: <span class="java"><a href="javascript:usdlc.edit_source({value:'java.coffee',path:'server/gwt/java.coffee',category:'gwt'})">java.coffee</a></span><span class="index"><a href="javascript:usdlc.edit_source({value:'index.coffee',path:'server/gwt/index.coffee',category:'gwt'})">index.coffee</a></span><span class="script_extractor"><a href="javascript:usdlc.edit_source({value:'script_extractor.coffee',path:'server/script_extractor.coffee',category:'server'})">script_extractor.coffee</a></span></div>

<h4>REPL Instrumentation <span style="font-size:14px;">(<a href="http://www.screencast.com/t/7KkYTEKnLs">screencast</a>)</span></h4>

<p style="display: block;">Components can be instrumented in isolation using a REPL (read, execute, print, loop). Many systems, including Groovy, Python and Node-JS come standard with a REPL.</p>

<p style="display: block;"><strong>Example</strong>:&nbsp;<a href="https://github.com/uSDLC/FICL"><em><strong>FICL</strong></em></a>&nbsp;(Fast Integrated Command Language)&nbsp;<em><strong>Reference</strong></em>&nbsp;- A library used to automate procedures in systems using compiled languages. Clone it and add it to uSDLC2.</p>

<p style="display: block;"><em><strong>FICL</strong></em> comes with a simple REPL specifically designed for USDLC2 testing. For other languages you will need to load a script to provide similar functionality.</p>

<p style="display: block;">The second section is the REPL itself - reading lines from the 'console' and executing them.</p>

<p style="display: block;">The bridge is similar across languages instrumented though a REPL.</p>

<ol style="display: block;">
	<li>Make sure instrumented code is up to date</li>
	<li>Recognise pass and fail conditions in console output</li>
	<li>Load instrumentation scripts by file extension</li>
</ol>

<p style="display: block;">Playing sections starts the REPL and feeds it commands from the requested sections. Click ... to see the rest of the output.</p>

<div class="metadata Ref" style="display: block;">Ref: <span class="gwt"><a href="javascript:usdlc.edit_source({value:'gwt.js',path:'templates/gwt.js',category:'templates'})">gwt.js</a></span><span class="install-usdlc2"><a href="javascript:usdlc.edit_source({value:'install-usdlc2.sh',path:'install-usdlc2.sh',category:'.'})">install-usdlc2.sh</a></span><span class="go"><a href="javascript:usdlc.edit_source({value:'go.sh',path:'go.sh',category:'.'})">go.sh</a></span></div>

<h4>Server Integrated Instrumentation <span style="font-size:14px;">(<a href="http://www.screencast.com/t/vITHRFXP">screencast</a>)</span></h4>

<p style="display: block;">Instrumenting a production system server requires instrumentation code on the server accessible over HTTP. First we need to be able to start and stop the server. The following code would normally be part of the bridge. The gwt object has a method for loading server support.</p>

<pre title="coffee" type="coffee">
gwt = require 'gwt'
server = gwt.server()</pre>

<p class="metadata Ref" style="display: block;">We can now add one or more servers.</p>

<pre title="coffee" type="coffee">
start = "./go.sh server config=debug port=9019"
stop = 'server/http/terminate.coffee?signal=<span data-scayt_word="SIGKILL" data-scaytid="14">SIGKILL</span>'

server.add
  'roaster':
    <span data-scayt_word="url" data-scaytid="15">url</span>: 'http://localhost:9019'
    <span data-scayt_word="dir" data-scaytid="16">dir</span>: '../roaster'
    start_command: start
    <span data-scayt_word="stop_url" data-scaytid="17">stop_url</span>: stop</pre>

<p class="metadata Ref" style="display: block;">You can use <em>stop_command</em> or <em>stop_url</em>. Some servers have start and stop scripts, while others can easily be terminated except by internal process. Note that the URL is only accepted if in debug mode or if <em>terminate=allowed</em> is on the command line.</p>

<p class="metadata Ref" style="display: block;">The server also adds rules to start a server. In this example we attempt to start the server twice. The start command always checks to see if it is running before trying again.</p>

<pre title="gwt" type="gwt">
Given a running roaster server
and we start a roaster server</pre>

<p class="metadata Ref" style="display: block;">To instrument a running server write response pages. For unprocessed output, use <em>bin</em> - providing it with the server address and an optional dictionary of arguments. It will pass or fail the rule depending on server response codes. The response data is saved in a gwt object with the same name as the request (without path or extension).</p>

<pre title="coffee" type="coffee">
gwt.rules(
  /(\S+\.html?)/, (<span data-scayt_word="url" data-scaytid="20">url</span>) -&gt;
    server.roaster.bin <span data-scayt_word="url" data-scaytid="21">url</span>, <span data-scayt_word="usdlc2" data-scaytid="24">usdlc2</span>:true, test:true
  /contains '(.*)'/, (re) -&gt;
    response = server.roaster.last_response
    gwt.test new <span data-scayt_word="RegExp" data-scaytid="25">RegExp</span>(re).test(response)
)</pre>

<pre title="gwt" type="gwt">
Given a running roaster server
When we ask for /test/test_html.html
Then it contains 'This is a Test'</pre>

<p style="display: block;">&nbsp;As you control most instrumentation, use JSON to return information with <em>get</em>. If it contains an <em>error:true</em> member the the step will fail. Implicit checks are supported by providing a <em>next</em> call-back. This <em>next</em> method will need to call gwt.pass or fail.</p>

<pre title="coffee" type="coffee">
gwt.rules(
  /ask for (.*)/, (url) -&gt;
    server.roaster.get url, question:'Whatsit?'
  /question is '(.*)'/, (question) -&gt;
    response = server.roaster.last_response
    gwt.check response?.question, question
)</pre>

<p style="display: block;"> </p>

<pre title="gwt" type="gwt">
Given a running roaster server
When we ask for /test/reflect.coffee?question=Whatsit?
Then the question is 'Whatsit?'</pre>

<p style="display: block;">Links to the instrumentation in the production code-base will display is the references at the end of the section - once they are accessed once inside <em><strong>uSDLC2</strong></em>.</p>

<p style="display: block;">For links to code outside the current project:</p>

<ol style="display: block;">
	<li>Switch to the other project</li>
	<li>Select the bookshelf from the uSDLC tab (Alt-V).</li>
	<li>Switch back to your own project</li>
	<li>Make sure the cursor is in the correct section</li>
	<li>Open the file of interest from the bookshelf</li>
	<li>A link will appear in the bottom of the section</li>
</ol>

<p style="display: block;">You will need to protect instrumentation in production deployments. If you want to use them in a production environment, check the calling IP and confirm it is localhost&nbsp;(127.0.0.0) before accepting. Otherwise exclude the instrumentation path in the production configuration.</p>

<p style="display: block;">This section is unusual in that the code that is normally hidden in the bridge is on display. &nbsp;The bridge code accounts for this by loading Coffeescript before processing the GWT statements.</p>

<div class="metadata Ref" style="display: block;">Ref: <span class="Bridge"><a href="javascript:usdlc.bridge_editor()">Bridge</a></span><span class="Play"><a href="javascript:usdlc.play()">Play</a></span><span class="server"><a href="javascript:usdlc.edit_source({value:'server.coffee',path:'server/gwt/server.coffee',category:'gwt'})">server.coffee</a></span><span class="reflect"><a href="javascript:usdlc.edit_source({value:'reflect.coffee',path:'../roaster/test/reflect.coffee',category:'test'})">reflect.coffee</a></span><span class="test_html"><a href="javascript:usdlc.edit_source({value:'test_html.html',path:'../roaster/test/test_html.html',category:'test'})">test_html.html</a></span><span class="go"><a href="javascript:usdlc.edit_source({value:'go.sh.bat',path:'go.sh.bat',category:'.'})">go.sh.bat</a></span><span class="install-usdlc2"><a href="javascript:usdlc.edit_source({value:'install-usdlc2.sh',path:'install-usdlc2.sh',category:'.'})">install-usdlc2.sh</a></span><span class="Usdlc2SocketClient"><a href="javascript:usdlc.edit_source({value:'Usdlc2SocketClient.java',path:'support/Usdlc2SocketClient.java',category:'support'})">Usdlc2SocketClient.java</a></span><span class="save"><a href="javascript:usdlc.edit_source({value:'save.coffee',path:'server/http/save.coffee',category:'http'})">save.coffee</a></span><span class="index"><a href="javascript:usdlc.edit_source({value:'index.coffee',path:'server/gwt/index.coffee',category:'gwt'})">index.coffee</a></span><span class="base"><a href="javascript:usdlc.edit_source({value:'base.coffee',path:'server/gwt/base.coffee',category:'gwt'})">base.coffee</a></span><span class="gwt"><a href="javascript:usdlc.edit_source({value:'gwt.coffee',path:'scripts/gwt.coffee',category:'scripts'})">gwt.coffee</a></span><span class="init"><a href="javascript:usdlc.edit_source({value:'init.coffee',path:'init.coffee',category:'.'})">init.coffee</a></span><span class="instrument"><a href="javascript:usdlc.edit_source({value:'instrument.coffee',path:'instrument.coffee',category:'.'})">instrument.coffee</a></span></div>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee">require './Server_Integrated_Instrumentation_screencast_'</textarea></p>

<h4>Code Injection</h4>

<p style="display: block;">Code injection can be used for all interactive languages such as Groovy, Ruby, Python or JavaScript. They require a transport mechanism to make the files available and code on the target system to ingest and run the injected code.</p>

<p style="display: block;">The transport depends on the target system. For servers, a HTTP request is easiest. For browsers they can make a web-socket connection to uSDLC. For many systems it is just a matter of copying the files in a known location.</p>

<p style="display: block;">Running injected code involves a security risk. This is easily mitigated with basic precautions - such that uSDLC must be running on the same computer as the target system.</p>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<div class="metadata Ref" style="display: block;">Ref: <span class="java"><a href="javascript:usdlc.edit_source({value:'java.coffee',path:'server/gwt/java.coffee',category:'gwt'})">java.coffee</a></span><span class="processes"><a href="javascript:usdlc.edit_source({value:'processes.coffee',path:'server/gwt/processes.coffee',category:'gwt'})">processes.coffee</a></span><span class="index"><a href="javascript:usdlc.edit_source({value:'index.coffee',path:'server/gwt/index.coffee',category:'gwt'})">index.coffee</a></span><span class="script_extractor"><a href="javascript:usdlc.edit_source({value:'script_extractor.coffee',path:'server/script_extractor.coffee',category:'server'})">script_extractor.coffee</a></span><span class="play"><a href="javascript:usdlc.edit_source({value:'play.coffee',path:'client/ckeditor/play.coffee',category:'ckeditor'})">play.coffee</a></span><span class="browser"><a href="javascript:usdlc.edit_source({value:'browser.coffee',path:'server/gwt/browser.coffee',category:'gwt'})">browser.coffee</a></span><span class="instrument_browser"><a href="javascript:usdlc.edit_source({value:'instrument_browser.js',path:'support/instrument_browser.js',category:'support'})">instrument_browser.js</a></span><span class="server"><a href="javascript:usdlc.edit_source({value:'server.sh',path:'server.sh',category:'.'})">server.sh</a></span></div>

<h5>Browser / JavaScript <span style="font-size:11px;">(<a href="http://www.screencast.com/t/H755mWDkCLu">Screencast</a>)</span></h5>

<p style="display: block;"><em><strong>uSDLC2</strong></em> can instrument any browser client in a test-agnostic way by injecting JavaScript. This means you can use other client-side test frameworks if you so wish and just trigger then from <em><strong>uSDLC2</strong></em>.&nbsp;</p>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<div class="metadata Ref" style="display: block;">Ref: <span class="project-init"><a href="javascript:usdlc.edit_source({value:'project-init.coffee',path:'boot/project-init.coffee',category:'boot'})">project-init.coffee</a></span><span class="processes"><a href="javascript:usdlc.edit_source({value:'processes.coffee',path:'server/gwt/processes.coffee',category:'gwt'})">processes.coffee</a></span><span class="sockets"><a href="javascript:usdlc.edit_source({value:'sockets.coffee',path:'server/gwt/sockets.coffee',category:'gwt'})">sockets.coffee</a></span><span class="browser"><a href="javascript:usdlc.edit_source({value:'browser.coffee',path:'server/gwt/browser.coffee',category:'gwt'})">browser.coffee</a></span><span class="server"><a href="javascript:usdlc.edit_source({value:'server.coffee',path:'server/gwt/server.coffee',category:'gwt'})">server.coffee</a></span></div>

<h6>'Live' Browser</h6>

<p style="display: block;">The target page must include a script found at <em>support/instrument_browser.js</em>, or replicate the code in the project under test. It opens a web-socket to uSDLC2 and waits for instructions. By default this socket is on&nbsp;<em>localhost</em>, so it cannot be accessed by external means. You can change the uSDLC2 address by presetting the host.</p>

<div style="background-color: rgb(238, 238, 238); border: 1px solid rgb(204, 204, 204); padding: 5px 10px; display: block;"><code>&lt;script&gt;<br />
&nbsp;&nbsp;<strong>window.usdlc2 = { host: "localhost" };</strong><br />
&lt;/script&gt;<br />
&lt;script<br />
&nbsp; src="http://localhost:9009/support/usdlc2_browser.js"&gt;<br />
&lt;/script&gt;</code></div>

<p style="display: block;">&nbsp;GWT provides a browser object with helper functions. Use it to &nbsp;open up a browser page. If a browser is not selected, the system default is used. If retain is set true, then the browser window is left open - good for hybrid automatic and manual testing. The default is false.</p>

<pre title="coffee" type="coffee">
gwt = require 'gwt'
browser = gwt.browser()
host = "http://localhost:"

gwt.rules(
  /server on port (\d{1,4})/, (@port) -&gt; @pass()
  /base url of (\S+)/, (@base) -&gt; @pass()
  /ask for a page (\S+)/, (@page) -&gt;
    url = host+@port+'/'+@base+@page
    @page = browser.page('live').open url, retain: false
    @pass()
  /get a connection/, -&gt;
    @page.once 'open', =&gt; @pass()
    @page.once 'error', =&gt; @fail()
)</pre>

<pre title="gwt" type="gwt">
Given a server on port 9009
  with a base url of support/
When we ask for a page usdlc2_browser_sample.html
Then we get a connection</pre>

<p style="display: block;">&nbsp;Javascript can be sent to the waiting browser with <em>inject(js)</em>. Anything sent to console.log() will be piped to stdout, so you can use <em>expect(pass, fail, end)</em> to process the results.</p>

<pre title="coffee" type="coffee">
gwt.rules(
  /ask for some console output/, -&gt;
    @page.inject "console.log(window.location)"
    @pass()
  /receive the expected output back/, -&gt;
    @expect /"port":"9009"/
)</pre>

<pre title="gwt" type="gwt">
When we ask for some console output
Then we receive the expected output back</pre>

<p style="display: block;">&nbsp;Console logging functions with multiple parameters have them all sent space separated. Objects are sent in JSON format while strings and other primatives are sent as-is. The JSON format is different to a native console.log() function. The console functions include:</p>

<ul style="display: block;">
	<li><em>console.assert(bool, args...)</em> - acts like error() if bool is false</li>
	<li><em>console.error(args...)</em> - same as log but includes a stack trace</li>
	<li><em>console.log(args...)</em></li>
</ul>

<p style="display: block;">In the above example, if the expected text does not happen, gwt waits 30 seconds before failing the instrumentation. Synchronous tests can respond to pass and fail. Below is a typical hybrid. The example is a simple page section where pressing a "List" button causes a table to fill with data. Checking DOM elements is synchronous and will fail or pass immediately. Pressing a button and waiting for table contents (or any DOM element) to change is potentially asynchronous. If you are using a front-end framework like angular-js you may be able to register a callback or worker. Otherwise, gwt provides a <em>wait_for</em> function that will poll every second for 30 seconds or until the correct value is provided.</p>

<pre title="coffee" type="coffee">
gwt.rules(
  /results table contains (\d+) entries/, (row_count) -&gt;
    gwt.monitor_output =
      pass: /^Passed:/m
      fail: /^Failed:/m
    @page.inject row_count, (row_count) -&gt;
      table = document.getElementById('results')
      return gwt.fail("No results table") if not table
      gwt.wait_for -&gt;
        rows = table.getElementsByTagName('tr')
        return +row_count is rows.length
  /click on the (\S+) Button/, (button_name) -&gt;
    @page.inject button_name, (button_name) -&gt;
      button =
        document.getElementById("#{button_name}_Button")
      return gwt.fail("No list button") if (not button)
      button.click()
      gwt.pass()
)</pre>

<pre title="gwt" type="gwt">
Given the results table contains 0 entries
When we click on the List Button
Then the results table contains 3 entries</pre>

<div class="metadata Ref" style="display: block;">Ref: <span class="Bridge"><a href="javascript:usdlc.bridge_editor()">Bridge</a></span><span class="Play"><a href="javascript:usdlc.play()">Play</a></span><span class="instrument_browser_sample"><a href="javascript:usdlc.edit_source({value:'instrument_browser_sample.html',path:'support/instrument_browser_sample.html',category:'support'})">instrument_browser_sample.html</a></span><span class="browser"><a href="javascript:usdlc.edit_source({value:'browser.coffee',path:'server/gwt/browser.coffee',category:'gwt'})">browser.coffee</a></span></div>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<h6>Headless Browser</h6>

<p style="display: block;">The above will open the system default web browser. For continuous integration it makes sense to use a headless browser. Here is the same example using PhantomJS. Note that the visible bridge code here repeats all the tests for reference. In a live situation the common tests would reside in the bridge code for a parent section.</p>

<pre title="coffee" type="coffee">
gwt = require 'gwt'
browser = gwt.browser()
host = "http://localhost:"

gwt.rules(
  /server on port (\d{1,4})/, (@port) -&gt;
    @page = browser.page('hdls')
    @pass()
  /a headless browser/, -&gt;
    @page.platform 'phantomjs', -&gt; gwt.pass()
  /base url of (\S+)/, (@base) -&gt; @pass()
  /ask for a page (\S+)/, (@url) -&gt;
    url = host+@port+'/'+@base+@url
    @page.open url, retain: false
    @page.once 'open', =&gt;
      @pass("Opened #{@url}")
    @page.once 'error', =&gt;
      @fail("Failed to open #{@url}")
  /click on the (\S+) Button/, (button_name) -&gt;
    @expect /^Passed:/m, /^Failed:/m
    @page.inject button_name, (button_name) -&gt;
      button =
        document.getElementById("#{button_name}_Button")
      return gwt.fail("No list button") if (not button)
      button.click()
      gwt.pass("Clicked")
  /results table contains (\d+) entries/, (row_count) -&gt;
    @page.inject row_count, (row_count) -&gt;
      table = document.getElementById('results')
      return gwt.fail("No results table") if not table
      gwt.wait_for -&gt;
        rows = table.getElementsByTagName('tr')
        if +row_count is rows.length
          rows = (row.innerHTML for row in rows)
          console.log rows.join('\n')
          return true
        return false
)</pre>

<pre title="gwt" type="gwt">
Given a server on port 9009
  and a headless browser
  with a base url of support/
When we ask for a page usdlc2_browser_sample.html
  and we click on the List Button
Then the results table contains 3 entries</pre>

<p style="display: block;"> </p>

<div class="metadata Ref" style="display: block;">Ref: <span class="Bridge"><a href="javascript:usdlc.bridge_editor()">Bridge</a></span><span class="Play"><a href="javascript:usdlc.play()">Play</a></span><span class="usdlc2_browser_sample"><a href="javascript:usdlc.edit_source({value:'usdlc2_browser_sample.html',path:'support/usdlc2_browser_sample.html',category:'support'})">usdlc2_browser_sample.html</a></span></div>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<h5>​Server / Roaster / Node-JS / Coffeescript</h5>

<h5>Mobile - FICL</h5>

<p style="display: block;">Some systems are static and can't be easily rebuilt on-the-fly for instrumentation. This includes many large Java and .NET system as well as most mobile devices. For these environments we provide FICL (fast integrated configuration language) - a very lightweight system for injecting instrumentation. There are Java versions for Android and C versions for .NET and iOS.</p>

<h5 style="display: block;">Mobile - Socket (<a href="http://www.screencast.com/t/Dms9N3H7">screencast</a>)</h5>

<p style="display: block;">In most cases even FICL can be over-kill. <em><strong>uSDLC2</strong></em> provides a simple socket server that can be easily accessed from any platform with a network connection. The support directory provides clients for Coffeescript (Node), Java and C, where the latter two will cover most platforms that need this approach. The default socket is 9089. Other languages and platforms are easy to add since basic TCP sockets are available almost everywhere.</p>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee">socket_server = gwt.socket_server()
clients = {}

gwt.rules(
  /socket server on port (\d*)/, (@port) -&gt;
    @pass()
  /start the sample (\w+) client called (\w+)/,
  (type, name) -&gt;
    gwt.shell gwt.run_client()
    server = socket_server @port, (client_id, send) =&gt;
      clients[client_id] = send
      @check client_id, name
  /send (\w+) a (\w+) command.* '(.*)'/, (id, cmd, msg) -&gt;
    clients[id](cmd, msg)
    @pass()
  /(\w+) responds with '(.*)'/, (id, expected) -&gt;
    @expect expected
)</textarea></p>

<h6 style="display: block;">Node Coffeescript Socket Client</h6>

<pre title="coffee" type="coffee">
gwt = require 'gwt'
socket_server = gwt.socket_server()
socket_client = require 'support/usdlc2_socket_client'
clients = {}
cmds =
  count: (line) -&gt;
    return "#{line.length} characters"

gwt.rules(
  /socket server on port (\d*)/, (@port) -&gt;
    @pass()
  /connection from a client named (\w+)/, (name) -&gt;
    ########
    client = socket_client name,'127.0.0.1',@port,cmds
    ########
    ########
    server = socket_server @port, (client_id, send) =&gt;
    ########
      clients[client_id] = send
      @test client_id is name
  /send (\w+) a (\w+) command.* '(.*)'/, (id, cmd, m) -&gt;
    clients[id](cmd, m)
    @pass()
  /(\w+) responds with '(.*)'/, (id, expected) -&gt;
    @expect expected
)</pre>

<pre title="gwt" type="gwt">
Given a socket server on port 9089
When we receive a connection from a client named Fred
and we send Fred a count command for 'the rain in spain'
Then Fred responds with '17 characters'</pre>

<div class="metadata Ref" style="display: block;">Ref: <span class="Bridge"><a href="javascript:usdlc.bridge_editor()">Bridge</a></span><span class="Play"><a href="javascript:usdlc.play()">Play</a></span><span class="socket_server"><a href="javascript:usdlc.edit_source({value:'socket_server.coffee',path:'server/gwt/socket_server.coffee',category:'gwt'})">socket_server.coffee</a></span><span class="usdlc2_socket_client"><a href="javascript:usdlc.edit_source({value:'usdlc2_socket_client.c',path:'support/usdlc2_socket_client.c',category:'support'})">usdlc2_socket_client.c</a></span></div>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<h6>Java Socket Client</h6>

<p style="display: block;">Consists of a single class <em>Usdlc2SocketClient.java</em> that you can link in to your system. Most environments support the java.net library. Because it only connects to a specific host, it is possible to leave the client code in-place during development.</p>

<p style="display: block;">This is a simple mock mobile device. In this case all it does is set up a uSDLC2 socket and respond to one command. In a real system, you would call&nbsp;<em>client.startCommandProcessor()</em> to run the tests on a separate thread.</p>

<p style="display: block;">Commands are in a <em>Hashtable</em> keyed on command name. The value is an instance of&nbsp;<em>Usdlc2SocketClient.Command</em> with a <em>run()</em> method. It provides a list of parameters where the first is the command name.</p>

<pre title="java" type="java">
import java.util.*;

class Java_Socket_Client {
  
  public static void main(String[] args) {
    String name = "Tom";
    String host = "127.0.0.1";
    int port = 9089;
    if (args.length &gt; 1) name = args[0];
    if (args.length &gt; 2) {
      port = Integer.parseInt(args[1]);
    }
    if (args.length &gt; 3) host = args[2];

    Hashtable commands = new Hashtable();
    
    // make a socket connection to the uSDCL2 Server
    final Usdlc2SocketClient client =
      new Usdlc2SocketClient(name,host,port,commands);
    
    // Commands are a hastable of name against an
    // innder class Usdlc2SocketClient.Command
    commands.put("count",
    new Usdlc2SocketClient.Command() {
      public void run(String[] params) {
        client.send(params[1].length() + " characters");
      }
    });
    
    // Read one line from the server and create a
    // command to run. Normally use
    // client.startCommandProcessor() to read and
    // call commands on a separate thread.
    while (!client.closing) client.commandProcessor();
  }
}
</pre>

<pre title="gwt" type="gwt">
Given a socket server on port 9089
When we start the sample Java client called Tom
and we send Tom a count command for 'the rain in spain'
Then Tom responds with '17 characters'</pre>

<p style="display: block;"> </p>

<div class="metadata Ref" style="display: block;">Ref: <span class="Usdlc2SocketClient"><a href="javascript:usdlc.edit_source({value:'Usdlc2SocketClient.java',path:'support/Usdlc2SocketClient.java',category:'support'})">Usdlc2SocketClient.java</a></span><span class="Bridge"><a href="javascript:usdlc.bridge_editor()">Bridge</a></span><span class="Play"><a href="javascript:usdlc.play()">Play</a></span><span class="java"><a href="javascript:usdlc.edit_source({value:'java.coffee',path:'server/gwt/java.coffee',category:'gwt'})">java.coffee</a></span><span class="socket_server"><a href="javascript:usdlc.edit_source({value:'socket_server.coffee',path:'server/gwt/socket_server.coffee',category:'gwt'})">socket_server.coffee</a></span></div>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee">java = gwt.java out: 'gen/classes'
java.compile 'support/uSDLC2SocketClient.java'
gwt.run_client = java.run_command</textarea></p>

<h6>C Socket Client for Threads</h6>

<p style="display: block;">The other common language for mobile and embedded systems is C or it's variants such as C++ and C#. The sample file to include, <em>usdlc_socket_client.c</em>&nbsp;is likely to need tweaking for different environments.</p>

<pre title="c" type="c">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;strings.h&gt;
#include &lt;unistd.h&gt;
#include "support/usdlc2_socket_client.h"

char* cmdProc(char *cmd, char **prms, int np, int fd) {
  if (strcmp(cmd, "count") == 0) {
    char result[64];
    sprintf(result, "%lu characters",
            strlen(prms[1]));
    return uSDLC2_send(fd, result);
  }
  return NULL;
}

int main(int argc, char *argv[]) {
  char *name = "Harry", *host = "127.0.0.1";
  char *last_rc = "";
  int port = 9089;
  if (argc &gt; 1) name = argv[1];
  if (argc &gt; 2) port = atoi(argv[1]);
  if (argc &gt; 3) host = argv[3];
  printf("uSDLC2 Client %s opening on %s:%d\n",
         name, host, port);
  
  // Calling as it is here will lock the program until
  // the program exits on command from the server.
  // In practice the call will be wrapped up and
  // run in a thread - or spawned as a separate process
  while (1) {
    char *rc =
    uSDLC2_socket_client(name, host, port, cmdProc);
    if (rc) {
      if (strcmp(rc, "__end__") == 0) break;
      if (strcmp(rc, last_rc) != 0) printf("%s\n", rc);
      last_rc = rc;
      sleep(1);
    }
  }
}</pre>

<pre title="gwt" type="gwt">
Given a socket server on port 9089
When we start the sample C client called Harry
and send Harry a count command for 'the rain in spain'
Then Harry responds with '17 characters'</pre>

<p style="display: block;"> </p>

<div class="metadata Ref" style="display: block;">Ref: <span class="usdlc2_socket_client"><a href="javascript:usdlc.edit_source({value:'usdlc2_socket_client.c',path:'support/usdlc2_socket_client.c',category:'support'})">usdlc2_socket_client.c</a></span><span class="Bridge"><a href="javascript:usdlc.bridge_editor()">Bridge</a></span><span class="Play"><a href="javascript:usdlc.play()">Play</a></span><span class="compiler"><a href="javascript:usdlc.edit_source({value:'compiler.coffee',path:'server/gwt/compiler.coffee',category:'gwt'})">compiler.coffee</a></span><span class="c"><a href="javascript:usdlc.edit_source({value:'c.coffee',path:'server/gwt/c.coffee',category:'gwt'})">c.coffee</a></span><span class="socket_server"><a href="javascript:usdlc.edit_source({value:'socket_server.coffee',path:'server/gwt/socket_server.coffee',category:'gwt'})">socket_server.coffee</a></span></div>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee">c = gwt.c out: 'gen/out'
c.compile "support/usdlc2_socket_client.c"
gwt.run_client = c.run_command</textarea></p>

<h6>C Socket Client for Events</h6>

<h2>The Bridge</h2>

<p style="display: block;">The bridge is code that connects rules to the operational system and other external resources. It is recorded within the document and extracted to be run. Any&nbsp;GWT block can access bridge code from it's section and all connected parent sections.</p>

<p style="display: block;">Every section can have associated bridge code. When played, the bridge for this section and all parents are available.</p>

<p style="display: block;">Bridge code is written in CoffeeScript, although any JavaScript variant can be made available.</p>

<p style="display: block;">Call&nbsp;<em>gwt.rules</em>&nbsp;with paired parameters being a regular expression and code to execute. Complete a step and move on with</p>

<ul style="display: block;">
	<li>@pass(message)</li>
	<li>@fail(message)</li>
	<li>@test(boolean, message) - pass or fail based on a boolean value</li>
	<li>@check(value, to_be) - compare two values, same is a pass</li>
	<li>@check_for_error(error, message) - fail on error, otherwise pass</li>
	<li>@todo(message) - fail with a TODO marker</li>
	<li>@skip(message) - pass with a SKIP marker</li>
	<li>@includes_text(text) - pass if system output includes the text</li>
	<li>@matches_text(regex) - pass if regex finds a match in output</li>
	<li>@expect(pass, fail, end) - monitor output for conditional regex</li>
</ul>

<p style="display: block;">Setting&nbsp;<em>@expect_failure</em>&nbsp;will reverse the test results.</p>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee"></textarea></p>

<div class="metadata Ref" style="display: block;">Ref:&nbsp;<span class="bridge"><a href="javascript:usdlc.edit_source({value:'bridge.coffee',path:'client/ckeditor/bridge.coffee',category:'ckeditor'})">bridge.coffee</a></span><span class="play"><a href="javascript:usdlc.edit_source({value:'play.coffee',path:'client/ckeditor/play.coffee',category:'ckeditor'})">play.coffee</a></span></div>

<h3>Rule Cascade</h3>

<p style="display: block;">If rules are to be common across sections, move them up to a parent that is available to both. If rules share common functionality, move that to a function and elevate it to a parent bridge.</p>

<h3>The&nbsp;<em>gwt</em>&nbsp;Object</h3>

<h3>Rules</h3>

<h4>Regular Expressions</h4>

<p style="display: block;">The first regular expression that matches a statement is used. It can use braces to mark parameters to pass to the action.</p>

<h4>Actions</h4>

<p style="display: block;">Each action counts as a test and must pass or fail before the instrumentation will continue. Most actions interact with production code through a REPL, an API, the browser or FICL.</p>

<h3>Asynchronous Support</h3>

<p style="display: block;">A rule is complete when it is marked pass or fail.&nbsp;Each rule has a queue for&nbsp;&nbsp;asynchronous operations. Each queue entry&nbsp;will complete and allow the next to start when @pass() is called. If there are no more steps, @pass() will complete the rule as usual. If @fail is called all further steps are skipped and the rule fails.</p>

<pre style="display: block;" type="gwt">
A rule with steps
A rule that would fail mid-step if we permitted it
</pre>

<div class="metadata Ref" style="display: block;">Ref: <span class="Bridge"><a href="javascript:usdlc.bridge_editor()">Bridge</a></span><span class="Play"><a href="javascript:usdlc.play()">Play</a></span><span class="base"><a href="javascript:usdlc.edit_source({value:'base.coffee',path:'server/gwt/base.coffee',category:'gwt'})">base.coffee</a></span><span class="index"><a href="javascript:usdlc.edit_source({value:'index.coffee',path:'server/gwt/index.coffee',category:'gwt'})">index.coffee</a></span><span class="files"><a href="javascript:usdlc.edit_source({value:'files.coffee',path:'server/http/files.coffee',category:'http'})">files.coffee</a></span></div>

<p style="display: block;"><textarea readonly="readonly" source="true" style="display: none;" type="gwt.coffee">count = 0

# async function that waits 1/10th of a sec then checks value
# should fail if another piece of code races ahead
heartbeat = (expects) -&gt; gwt.queue -&gt;
  tick = -&gt;
    gwt.expect(count++, expects)
  setTimeout(tick, 100)

gwt.rules(
  /A rule with steps/, -&gt;
    heartbeat 0
    heartbeat 1
    heartbeat 2
  
  /A rule that would fail mid-step/, -&gt;
    @expect_failure = true
    
    @queue -&gt;
      count = 0
      @pass()
      
    heartbeat 0
    heartbeat 5
    heartbeat 2
)</textarea></p>

<h2>Play Instrumentation</h2>

<p style="display: block;">Playing the instrumentation brings up a screen and displays output as it comes. Groups that include failures are shaded red.</p>

<h3>Console Output</h3>

<p style="display: block;">Details and console output are captured. Only the first line is displayed. Click on ... to see the rest.</p>

<h3>TAP</h3>

<p style="display: block;">This screen is a fancy formatting for the TAP (test anything protocol).</p>

<h3>Command Line Execution</h3>

<p style="display: block;">Copy the command at the top of the screen and run it in a terminal. It can also be used for testing during development and continuous integration.</p>
</body>
</html>
